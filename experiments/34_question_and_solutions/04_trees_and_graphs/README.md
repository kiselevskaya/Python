
**Trees and Graphs**


**tree_is_balanced.py**

    Implement a function to check if a binary  tree is balanced.
    For the purpose of this question, a balanced tree is defined to be a tree such that the heights of the two subtrees of any node never differ by more than one.


**route_between_nodes.py**

    Given a directed graph, design an algorithm to find out whether there is a route between two nodes.


**minimal_height_binary_search_tree.py**

    Given a sorted (increasing order) array, write an algorithm to create a binary search tree with minimal height


**list_for_each_depth.py**

    Given a binary tree, design an algorithm which creates a linked list of all the nodes at each depth
     (e.g., if you have a tree with depth D, you'll have D linked lists).


**is_binary_search_tree.py**

    Implement a function to check if binary tree is a binary search tree.


**next_node_bst.py**

    Write an algorithm to find the 'next' node (i.e., in-order successor) of a given node in a binary search tree.
    You may assume that each node has a link to its parent.


**common_ancestor.py**

    Design an algorithm and write code to find the first common ancestor of two nodes in a binary tree.
    Avoid storing additional nodes in a data structure.
    Note: This is not necessary a binary search tree.


**subtree.py**

    You have two very large binary trees: T1, with millions of nodes, and T2, with hundreds of nodes.
    Create an algorithm to decide if T2 is a subtree of T1.

    A tree T2 is a subtree of T1 if there exists a node n in T1 such that the subtree of n is identical to T2.
    That is, if you cut off the tree at node n, the two trees would be identical.
